---
import ReactIcon from './ReactIcon.jsx';

interface Stat {
  number: number;
  suffix: string;
  label: string;
  icon: string;
}

interface Props {
  stats: Stat[];
  darkMode?: boolean;
}

const { stats, darkMode = false } = Astro.props;
const textColor = darkMode ? 'text-white' : 'text-vintage-dark';
const accentColor = darkMode ? 'text-vintage-gold' : 'text-vintage-gold';
---

<div class="stats-counter-container">
  <div class="grid grid-cols-2 md:grid-cols-4 gap-8 md:gap-12">
    {stats.map((stat, index) => (
      <div class="stat-item text-center group" data-index={index}>
        <!-- Icon -->
        <div class={`w-16 h-16 mx-auto mb-4 rounded-full bg-vintage-gold/10 flex items-center justify-center ${accentColor} group-hover:bg-vintage-gold group-hover:text-white transition-all duration-300`}>
          <ReactIcon name={stat.icon} size={32} />
        </div>

        <!-- Number -->
        <div class={`text-4xl md:text-5xl font-serif font-bold mb-2 ${textColor}`}>
          <span class="stat-number" data-target={stat.number} data-suffix={stat.suffix}>
            0{stat.suffix}
          </span>
        </div>

        <!-- Label -->
        <p class={`text-sm md:text-base uppercase tracking-wider font-semibold ${darkMode ? 'text-white/70' : 'text-gray-600'}`}>
          {stat.label}
        </p>
      </div>
    ))}
  </div>
</div>

<script>
  (function() {
    let hasAnimated = false;

    function animateNumber(element, target, suffix, duration = 2000) {
      const start = 0;
      const increment = target / (duration / 16); // 60fps
      let current = start;

      const timer = setInterval(() => {
        current += increment;
        if (current >= target) {
          current = target;
          clearInterval(timer);
        }

        // Format number based on size
        let displayValue;
        if (target >= 1000) {
          displayValue = Math.floor(current).toLocaleString();
        } else if (target < 10) {
          displayValue = current.toFixed(1);
        } else {
          displayValue = Math.floor(current);
        }

        element.textContent = displayValue + suffix;
      }, 16);
    }

    function startCounters() {
      if (hasAnimated) return;

      const statNumbers = document.querySelectorAll('.stat-number');
      statNumbers.forEach((element) => {
        const target = parseFloat(element.getAttribute('data-target'));
        const suffix = element.getAttribute('data-suffix') || '';
        animateNumber(element, target, suffix);
      });

      hasAnimated = true;
    }

    // Intersection Observer for scroll-triggered animation
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            startCounters();
          }
        });
      },
      {
        threshold: 0.5, // Trigger when 50% visible
      }
    );

    const container = document.querySelector('.stats-counter-container');
    if (container) {
      observer.observe(container);
    }
  })();
</script>

<style>
  .stat-item {
    animation: fadeInUp 0.6s ease-out forwards;
    opacity: 0;
  }

  .stat-item:nth-child(1) {
    animation-delay: 0.1s;
  }

  .stat-item:nth-child(2) {
    animation-delay: 0.2s;
  }

  .stat-item:nth-child(3) {
    animation-delay: 0.3s;
  }

  .stat-item:nth-child(4) {
    animation-delay: 0.4s;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(30px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
</style>
